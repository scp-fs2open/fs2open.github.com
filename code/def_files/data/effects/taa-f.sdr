// Temporal Anti-Aliasing resolve shader
// Based on "Temporal Reprojection Anti-Aliasing in INSIDE" and UE4 TAA

#include "gamma.sdr"

layout (std140) uniform genericData {
	vec2 texelSize;
	float feedbackMin;
	float feedbackMax;
};

in vec4 fragTexCoord;
out vec4 fragOut0;

uniform sampler2D scene;
uniform sampler2D history;
uniform sampler2D depthTex;
uniform sampler2D velocityTex;

// Catmull-Rom cubic filter for high-quality history sampling
vec4 sampleHistoryCatmullRom(vec2 uv) {
    vec2 position = uv / texelSize;
    vec2 centerPosition = floor(position - 0.5) + 0.5;
    vec2 f = position - centerPosition;
    vec2 f2 = f * f;
    vec2 f3 = f * f2;

    // Catmull-Rom weights
    vec2 w0 = -0.5 * f3 + f2 - 0.5 * f;
    vec2 w1 = 1.5 * f3 - 2.5 * f2 + 1.0;
    vec2 w2 = -1.5 * f3 + 2.0 * f2 + 0.5 * f;
    vec2 w3 = 0.5 * f3 - 0.5 * f2;

    vec2 w12 = w1 + w2;
    vec2 tc0 = (centerPosition - 1.0) * texelSize;
    vec2 tc3 = (centerPosition + 2.0) * texelSize;
    vec2 tc12 = (centerPosition + w2 / w12) * texelSize;

    // 5-tap approximation of 16-tap Catmull-Rom
    vec4 result = vec4(0.0);
    result += texture(history, vec2(tc12.x, tc0.y)) * (w12.x * w0.y);
    result += texture(history, vec2(tc0.x, tc12.y)) * (w0.x * w12.y);
    result += texture(history, vec2(tc12.x, tc12.y)) * (w12.x * w12.y);
    result += texture(history, vec2(tc3.x, tc12.y)) * (w3.x * w12.y);
    result += texture(history, vec2(tc12.x, tc3.y)) * (w12.x * w3.y);

    return max(result, vec4(0.0));
}

// RGB to YCoCg color space (better for neighborhood clamping)
vec3 RGB_to_YCoCg(vec3 rgb) {
    return vec3(
        0.25 * rgb.r + 0.5 * rgb.g + 0.25 * rgb.b,
        0.5 * rgb.r - 0.5 * rgb.b,
        -0.25 * rgb.r + 0.5 * rgb.g - 0.25 * rgb.b
    );
}

vec3 YCoCg_to_RGB(vec3 ycocg) {
    return vec3(
        ycocg.x + ycocg.y - ycocg.z,
        ycocg.x + ycocg.z,
        ycocg.x - ycocg.y - ycocg.z
    );
}

// Clip color to AABB in YCoCg space
vec3 clipToAABB(vec3 color, vec3 boxMin, vec3 boxMax) {
    vec3 center = 0.5 * (boxMax + boxMin);
    vec3 extents = 0.5 * (boxMax - boxMin);

    vec3 offset = color - center;
    vec3 ts = abs(extents / (offset + 0.0001));
    float t = clamp(min(min(ts.x, ts.y), ts.z), 0.0, 1.0);

    return center + offset * t;
}

void main() {
    vec2 uv = fragTexCoord.xy;

    // Sample velocity (motion vectors)
    vec2 velocity = texture(velocityTex, uv).xy;

    // Reproject to previous frame position
    vec2 historyUV = uv - velocity;

    // Sample current frame (3x3 neighborhood for clamping)
    vec3 currentColor = srgb_to_linear(texture(scene, uv).rgb);

    // Gather 3x3 neighborhood for variance clipping
    vec3 m1 = vec3(0.0);
    vec3 m2 = vec3(0.0);
    vec3 neighborMin = vec3(1e10);
    vec3 neighborMax = vec3(-1e10);

    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            vec2 offset = vec2(float(x), float(y)) * texelSize;
            vec3 neighbor = srgb_to_linear(texture(scene, uv + offset).rgb);
            vec3 neighborYCoCg = RGB_to_YCoCg(neighbor);

            m1 += neighborYCoCg;
            m2 += neighborYCoCg * neighborYCoCg;
            neighborMin = min(neighborMin, neighborYCoCg);
            neighborMax = max(neighborMax, neighborYCoCg);
        }
    }

    // Variance clipping (tighter than min/max AABB)
    m1 /= 9.0;
    m2 /= 9.0;
    vec3 sigma = sqrt(max(m2 - m1 * m1, vec3(0.0)));
    float varianceGamma = 1.0; // 1.0 for standard, increase for less ghosting but more flickering
    vec3 boxMin = m1 - varianceGamma * sigma;
    vec3 boxMax = m1 + varianceGamma * sigma;

    // Sample history with high-quality filtering
    vec3 historyColor;
    if (historyUV.x >= 0.0 && historyUV.x <= 1.0 && historyUV.y >= 0.0 && historyUV.y <= 1.0) {
        historyColor = sampleHistoryCatmullRom(historyUV).rgb;
    } else {
        // Off-screen: use current frame
        historyColor = currentColor;
    }

    // Convert to YCoCg for clamping
    vec3 currentYCoCg = RGB_to_YCoCg(currentColor);
    vec3 historyYCoCg = RGB_to_YCoCg(historyColor);

    // Clip history to neighborhood bounds
    vec3 clippedHistoryYCoCg = clipToAABB(historyYCoCg, boxMin, boxMax);
    vec3 clippedHistory = YCoCg_to_RGB(clippedHistoryYCoCg);

    // Compute blend factor based on how much clipping occurred
    float clipLength = length(clippedHistoryYCoCg - historyYCoCg);
    float velocityLength = length(velocity) * 100.0; // Scale velocity influence

    // More motion = less history, more clipping = less history
    float feedback = mix(feedbackMax, feedbackMin, clamp(clipLength * 10.0 + velocityLength, 0.0, 1.0));

    // Blend current and history
    vec3 result = mix(currentColor, clippedHistory, feedback);

    // Output in linear space (tonemapping happens later)
    fragOut0 = vec4(linear_to_srgb(result), 1.0);
}
